#!/usr/bin/env python
"""
pipelineStatsPlotter.py
19 August 2014
dent earl, dearl a soe ucsc edu

Script to take in stats.xml files generated by geneChckStatCreator.py
and visualize the results.
"""
# plotting boilerplate / cargo cult
import matplotlib
matplotlib.use('Agg')
#####
# the param pdf.fonttype allows for text to be editable in Illustrator.
# Use either Output Type 3 (Type3) or Type 42 (TrueType)
matplotlib.rcParams['pdf.fonttype'] = 42
import matplotlib.backends.backend_pdf as pltBack
import matplotlib.lines as lines
import matplotlib.patches as patches
import matplotlib.pyplot as plt
import matplotlib.pylab as pylab
from matplotlib.ticker import ScalarFormatter, FormatStrFormatter
import numpy
##############################
from argparse import ArgumentParser
from glob import glob
import os
import sys
sys.path.append(
  os.path.join(
    os.path.dirname(os.path.dirname(os.path.abspath(sys.argv[0]))), 'filters'))
import lib_stat_graph as lsg


class Stat(object):
  def __init__(self, name):
    self.name = name
    self.ok = 0.
    self.ok_transcripts = 0
    self.ok_transcriptsAonnations = 0
    self.outOfFrame = 0.
    self.outOfFrame_transcripts = 0
    self.outOfFrame_transcriptAnnotations = 0
    self.nonsynon = 0.
    self.nonsynon_transcripts = 0
    self.nonsynon_transcriptAnnotations = 0
    self.synon = 0.
    self.synon_transcripts = 0
    self.synon_transcriptAnnotations = 0
    self.nonsense = 0.
    self.nonsense_transcripts = 0
    self.nonsense_transcriptAnnotations = 0
    self.filteredOut = 0
    self.matchingMRna = 0


def InitArguments(parser):
  """ Initialize arguments for the program.

  Args:
    parser: an argparse parser object
  """
  parser.add_argument('--in_dir', type=str,
                      help='location of pipeline results dir')
  parser.add_argument('--distance', action='store_true', default=False,
                      help='x-axis is phylogenetic distance.')
  parser.add_argument('--perTranscript', action='store_true', default=False,
                      help='plot the number of things per transcript.')
  parser.add_argument(
    '--tags', type=str, default='ok,outOfFrame,synon,nonsynon,nonsense',
    help='comma separated list of tags,')
  parser.add_argument('--exclude', type=str, default='',
                      help='comma separated list of species to exclude')
  parser.add_argument('--out', dest='out', default='my_plot',
                      type=str,
                      help=('path/filename where figure will be created. No '
                            'extension needed. default=%(default)s'))
  parser.add_argument('--colors', dest='colors', default='brewer', type=str,
                      help=('color palatte mode. may be in (bostock, brewer, '
                            'mono, hcl_ggplot2) '
                            'default=%(default)s'))
  parser.add_argument('--color_index_offset', dest='color_index_offset',
                      type=int, default=0,
                      help=('index offset value to shift the starting point '
                            'of the selected color map. default=%(default)s'))
  parser.add_argument('--alpha', default=1.0, type=float,
                      help='alpha value for markers in --mode scatter')
  parser.add_argument('--dot_size', '--markersize', dest='markersize',
                      default=4.0, type=float,
                      help='value for markers in --mode scatter')
  parser.add_argument('--marker', dest='marker', default=None, type=str,
                      help='Marker to use.')
  parser.add_argument('--linewidth', dest='linewidth', default=2.0,
                      type=float,
                      help='Line width for the plot. default=%(default)s')
  parser.add_argument('--logy', dest='is_log_y', default=False,
                      action='store_true',
                      help='Put the y-axis into log. default=%(default)s')
  parser.add_argument('--logx', dest='is_log_x', default=False,
                      action='store_true',
                      help='Put the x-axis into log. default=%(default)s')
  parser.add_argument('--title', dest='title', type=str,
                      default='sentinel_value',
                      help='Plot title.')
  parser.add_argument('--xlabel', dest='xlabel', type=str,
                      default='sentinel_value',
                      help='X-axis label.')
  parser.add_argument('--ylabel', dest='ylabel', type=str,
                      default='sentinel_value',
                      help='Y-axis label.')
  parser.add_argument(
    '--xmin', dest='user_xmin', default=sys.maxint, type=float,
    help='xmin value.')
  parser.add_argument(
    '--xmax', dest='user_xmax', default=-sys.maxint, type=float,
    help='xmax value.')
  parser.add_argument(
    '--ymin', dest='user_ymin', default=sys.maxint, type=float,
    help='ymin value.')
  parser.add_argument(
    '--ymax', dest='user_ymax', default=-sys.maxint, type=float,
    help='ymax value.')
  parser.add_argument('--height', dest='height', default=4.0, type=float,
                      help='height of image, in inches. default=%(default)s')
  parser.add_argument('--width', dest='width', default=9.0, type=float,
                      help='width of image, in inches. default=%(default)s')
  parser.add_argument('--dpi', dest='dpi', default=300,
                      type=int,
                      help=('dots per inch of raster outputs, i.e. '
                            'if --outFormat is all or png. '
                            'default=%(default)s'))
  parser.add_argument('--out_format', dest='out_format', default='pdf',
                      type=str,
                      help=('output format [pdf|png|eps|all]. '
                            'default=%(default)s'))
  parser.add_argument('--no_legend', dest='is_legend', default=True,
                      action='store_false',
                      help=('Turns off the filename / color legend. '
                            'Helpful for large numbers of files.'))
  parser.add_argument('--regression', dest='regression', default=False,
                      action='store_true',
                      help='turn on a simple linear regression line')
  parser.add_argument('--jitter', dest='jitter', default=False,
                      action='store_true',
                      help='turn on jitter for certain plotting modes')
  parser.add_argument('--random_seed', dest='random_seed', default=None,
                      type=int,
                      help=('Random seed for use with --jitter and '
                            '--downsample  flags.'))
  parser.add_argument('--aspect_equal', dest='aspect_equal', default=False,
                      action='store_true',
                      help='Turn on equal aspect ratio for the plot')


def CheckArguments(args, parser):
  """ Verify that input arguments are correct and sufficient.

  Args:
    args: an argparse arguments object
    parser: an argparse parser object
  """
  args.recognized_modes = ['line', 'scatter', 'bar', 'column', 'hist',
                           'histogram', 'tick', 'barcode', 'point', 'contour',
                           'density', 'matrix']
  if args.dpi < 72:
    parser.error('--dpi %d less than screen res, 72. Must be >= 72.'
                 % args.dpi)
  if args.out_format not in ('pdf', 'png', 'eps', 'all'):
    parser.error('Unrecognized --out_format %s. Choose one from: '
                 'pdf png eps all.' % args.out_format)
  if args.colors not in ('bostock', 'brewer', 'mono'):
    parser.error('Unrecognized --colors %s palette. Choose one from: '
                 'bostock brewer mono.' % args.colors)
  if (args.out.endswith('.png') or args.out.endswith('.pdf') or
      args.out.endswith('.eps')):
    args.out = args.out[:-4]
  args.xmax = -sys.maxint
  args.xmin = sys.maxint
  args.ymax = -sys.maxint
  args.ymin = sys.maxint
  args.tags = args.tags.split(',')
  args.exclude = args.exclude.split(',')
  DefineColors(args)


def InitImage(args):
  """ Initialize a new image.

  Args:
    args: an argparse arguments object

  Returns:
    fig: a matplotlib figure object
    pdf: a matplotlib pdf drawing (backend) object
  """
  pdf = None
  if args.out_format == 'pdf' or args.out_format == 'all':
    pdf = pltBack.PdfPages(args.out + '.pdf')
  fig = plt.figure(figsize=(args.width, args.height),
                   dpi=args.dpi, facecolor='w')
  return (fig, pdf)


def EstablishAxes(fig, args):
  """ Create a single axis on the figure object.

  Args:
    fig: a matplotlib figure object
    args: an argparse arguments object

  Returns:
    ax: a matplotlib axis object
  Raises:
    ValueError: If an unknown spine location is passed.
  """
  # left 0.99 inches, right 0.54 inches, width 7.47 inches
  # bottom 0.68 inches, top 0.28 inches, height 3.04 inches
  args.axLeft = 0.99 / args.width
  args.axRight = 1.0 - (0.54 / args.width)
  args.axWidth = args.axRight - args.axLeft
  args.axBottom = 0.68 / args.height
  args.axTop = 1.0 - (0.28 / args.height)
  args.axHeight = args.axTop - args.axBottom
  ax = fig.add_axes([args.axLeft, args.axBottom,
                     args.axWidth, args.axHeight])
  ax.yaxis.set_major_locator(pylab.NullLocator())
  ax.xaxis.set_major_locator(pylab.NullLocator())
  for loc, spine in ax.spines.iteritems():
    if loc in ['left', 'bottom']:
      spine.set_position(('outward', 10))
    elif loc in ['right', 'top']:
      spine.set_color('none')
    else:
      raise ValueError('unknown spine location: %s' % loc)
  ax.xaxis.set_ticks_position('bottom')
  ax.yaxis.set_ticks_position('left')
  return ax


def DefineColors(args):
  """ Based on --colors, define the set of colors to use in the plot.

  Args:
    args: an argparse arguments object
  """
  # TODO: allow for a way to override the color list
  if args.colors == 'bostock':
    args.colors_light = ['#aec7e8',  # l blue
                         '#ffbb78',  # l orange
                         '#98df8a',  # l green
                         '#ff9896',  # l red
                         '#c5b0d5',  # l purple
                         '#c49c94',  # l brown
                         '#f7b6d2',  # l lavender
                         '#c7c7c7',  # l gray
                         '#dbdb8d',  # l olive
                         '#9edae5',  # l aqua
                        ]
    args.colors_medium = ['#1f77b4',  # d blue
                          '#ff7f0e',  # d orange
                          '#2ca02c',  # d green
                          '#d62728',  # d red
                          '#9467bd',  # d purple
                          '#8c564b',  # d brown
                          '#e377c2',  # d lavender
                          '#7f7f7f',  # d gray
                          '#bcbd22',  # d olive
                          '#17becf',  # d aqua
                         ]
    args.colors_dark = []
  elif args.colors == 'brewer':
    args.colors_light = [(136, 189, 230),  # l blue
                         (251, 178,  88),  # l orange
                         (144, 205, 151),  # l green
                         (246, 170, 201),  # l red
                         (191, 165,  84),  # l brown
                         (188, 153, 199),  # l purple
                         (240, 126, 110),  # l magenta
                         (140, 140, 140),  # l grey
                         (237, 221,  70),  # l yellow
                        ]
    args.colors_medium = [( 93, 165, 218),  # m blue
                          (250, 164,  58),  # m orange
                          ( 96, 189, 104),  # m green
                          (241, 124, 167),  # m red
                          (178, 145,  47),  # m brown
                          (178, 118, 178),  # m purple
                          (241,  88,  84),  # m magenta
                          ( 77,  77,  77),  # m grey
                          (222, 207,  63),  # m yellow
                         ]
    args.colors_dark = [( 38,  93, 171),  # d blue
                        (223,  92,  36),  # d orange
                        (  5, 151,  72),  # d green
                        (229,  18, 111),  # d red
                        (157, 114,  42),  # d brown
                        (123,  58, 150),  # d purple
                        (203,  32,  39),  # d magenta
                        (  0,   0,   0),  # black
                        (199, 180,  46),  # d yellow
                       ]
  elif args.colors == 'mono':
    args.colors_light = [(140, 140, 140),  # l grey
                        ]
    args.colors_medium = [( 77,  77,  77),  # m grey
                         ]
    args.colors_dark = [(  0,   0,   0),  # black
                       ]
  elif args.colors == 'hcl_ggplot2':
    args.colors_light = [(158, 217, 255),  # l blue
                         (246, 209, 146),  # l mustard
                         ( 93, 237, 189),  # l green
                         (255, 189, 187),  # l pink
                         (182, 228, 149),  # l olive
                         ( 51, 235, 236),  # l teal
                         (241, 194, 255),  # l purple
                         (255, 179, 234),  # l magenta
                        ]
    args.colors_medium = [( 98, 162, 209),  # m blue
                          (190, 154,  87),  # m mustard
                          (223, 133, 131),  # m pink
                          (  0, 183, 134),  # m green
                          (126, 173,  90),  # m olive
                          (  0, 180, 181),  # m teal
                          (187, 134, 209),  # m purple
                          (225, 122, 179),  # m magenta
                         ]
    args.colors_dark = [(  0, 163, 255),  # d blue
                        (213, 151,   0),  # d mustard
                        (  0, 201, 106),  # d green
                        (254, 102,  97),  # d pink
                        ( 98, 183,   0),  # d olive
                        (  1, 196, 200),  # d teal
                        (219,  95, 255),  # d purple
                        (255,  40, 201),  # d magenta
                       ]
  if isinstance(args.colors_light[0], tuple):
    CorrectColorTuples(args)


def CorrectColorTuples(args):
  """ Corrects the 0-255 values in colors_light and colors_medium to 0.0 - 1.0.

  Args:
    args: an argparse arguments object
  """
  for i in xrange(0, len(args.colors_light)):
    args.colors_light[i] = (args.colors_light[i][0] / 255.0,
                            args.colors_light[i][1] / 255.0,
                            args.colors_light[i][2] / 255.0,)
  for i in xrange(0, len(args.colors_medium)):
    args.colors_medium[i] = (args.colors_medium[i][0] / 255.0,
                             args.colors_medium[i][1] / 255.0,
                             args.colors_medium[i][2] / 255.0,)
  for i in xrange(0, len(args.colors_dark)):
    args.colors_dark[i] = (args.colors_dark[i][0] / 255.0,
                           args.colors_dark[i][1] / 255.0,
                           args.colors_dark[i][2] / 255.0,)


def ColorPicker(i, args):
  """ Returns a valid matplotlib color based on the index, plot mode and palette.

  Args:
    i: index, integer
    args: an argparse arguments object

  Returns:
    color: a valid matplotlib color, or a list of colors if mode is hist
           or a name of a valid matplotlib colormap or a matplotlib color map
           if the mode is contour
  """
  i += args.color_index_offset
  args.mode = 'scatter'
  if args.mode in ('column', 'bar'):
    return args.colors_light[i % len(args.colors_light)]
  elif args.mode in ('hist'):
    # hist requires a list of colors be returned
    colors = []
    for i in xrange(0, i):
      colors.append(args.colors_light[i % len(args.colors_light)])
    return colors
  elif args.mode in ('contour'):
    colors = 'k'
    return colors
  elif args.mode in ('line', 'scatter', 'tick', 'point', 'barcode', 'density'):
    return args.colors_medium[i % len(args.colors_medium)]


def MakeProxyPlots(order, args):
  """ Make some proxy plots for use with legends.

  Proxy plots are plots that are not actually drawn but whose
  colors are used for correctly populating a legend.

  Args:
    args: an argparse argument object.

  Returns:
    proxy_plots: A list of matplotlib plot objects.
  """
  if args.mode != 'hist':
    proxy_plots = []
    for i, afile in enumerate(order, 0):
      proxy_plots.append(
        plt.Rectangle(
          (0, 0), 1, 1,
          fc=ColorPicker(i, args),
          ec=ColorPicker(i, args)))
  else:
    proxy_plots = []
    for i, afile in enumerate(order, 0):
      proxy_plots.append(
        plt.Rectangle(
          (0, 0), 1, 1,
          fc=ColorPicker(len(order), args)[i],
          ec=ColorPicker(len(order), args)[i]))
  return proxy_plots


def MakeLegendLabels(order, args):
  """ Make labels for use with legends.

  Args:
    args: an argparse argument object

  Returns:
    legend_labels: A list of strings.
  """
  legend_labels = []
  for afile in order:
    legend_labels.append(afile)
  return legend_labels


def WriteImage(fig, pdf, args):
  """ Write the image to disk.

  Args:
    fig: a matplotlib figure object
    pdf: a matplotlib pdf drawing (backend) object
    args: an argparse arguments object
  """
  if args.out_format == 'pdf':
    fig.savefig(pdf, format = 'pdf')
    pdf.close()
  elif args.out_format == 'png':
    fig.savefig(args.out + '.png', format='png', dpi=args.dpi)
  elif args.out_format == 'all':
    fig.savefig(pdf, format='pdf')
    pdf.close()
    fig.savefig(args.out + '.png', format='png', dpi=args.dpi)
    fig.savefig(args.out + '.eps', format='eps')
  elif args.out_format == 'eps':
    fig.savefig(args.out + '.eps', format='eps')


def ReadFiles(args):
  """ Read and parse all input files.

  Args:
    args: an argparse arguments object

  Returns:
    stat_dict: a dictionary of Stat objects.
  """
  stat_dict = {}
  for d in glob(os.path.join(args.in_dir, 'metaFilter.*')):
    xml = os.path.join(d, 'stats.xml')
    name = os.path.dirname(xml).split('.')[-1]
    if name in args.exclude:
      continue
    stat = Stat(name)
    graph = lsg.readStatGraph(xml)
    tags = args.tags  # ['ok', 'nonsynon', 'synon', 'outOfFrame', 'nonsense']
    tuples = [(t, '%s_transcripts' % t, '%s_transcriptAnnotations' % t) for t in tags]
    for name, v_t, v_ta in tuples:
      stats = lsg.getTagStats(graph, name)
      setattr(stat, v_t, stats.tagTranscripts)
      setattr(stat, v_ta, stats.tagTranscriptAnnotations)
      setattr(stat, name, (100. * stats.tagTranscripts / stats.nodeTranscripts))
    stat_dict[stat.name] = stat
    transcripts = 0
    with open(os.path.join(d, 'mRnaCompare', 'counts.log'), 'r') as f:
      for line in f:
        line = line.strip()
        if line == '':
          break
        tokens = line.split()
        if tokens[0] == 'transcripts':
          transcripts = int(tokens[1])
          continue
        if tokens[0] in ['dropped_singleExons', 'dropped_missingSeqs',
                         'dropped_o_missingSeqs', 'dropped_mRnaNs',
                         'dropped_emptyAASeq', 'dropped_noStart',
                         'dropped_noStop']:
          stat.filteredOut += int(tokens[1])
          continue
        if tokens[0] == 'dropped_matchingMRna':
          stat.matchingMRna = int(tokens[1])
    denominator = transcripts - stat.filteredOut
    for name, v_t, v_ta in tuples:
      if not args.perTranscript:
        setattr(stat, name, 100. * getattr(stat, '%s_transcripts' % name) / denominator)
        # stat.nonsynon = 100. * stat.nonsynon_transcripts / denominator
      else:
        setattr(stat, name, getattr(stat, '%s_transcriptAnnotations' % name) / denominator)
        # stat.nonsynon = stat.nonsynon_transcriptAnnotations / denominator
  return stat_dict


def PlotData(stat_dict, ax, args):
  """ Plot two dimensional line or scatter data.

  Args:
    stat_dict: a dictionary of Stat objects
    ax: a matplotlib axis object
    args: an argparse arguments object
  """
  dists = {'C57B6NJ': 2e-06,
           'NZOHlLtJ': 3e-06,
           'NODShiLtJ': 6e-06,
           'FVBNJ': 6e-06,
           'LPJ': 6e-06,
           '129S1': 6e-06,
           'AKRJ': 7e-06,
           'BALBcJ': 7e-06,
           'AJ': 7e-06,
           'DBA2J': 8e-06,
           'CBAJ': 9e-06,
           'C3HHeJ': 9e-06,
           'WSBEiJ': 1.5e-05,
           'CASTEiJ': 0.001105,
           'PWKPhJ': 0.001106,
           'SPRETEiJ': 0.002107,
           'Rattus': 0.026107,
           }
  order = sorted(dists.keys(), key=lambda k: dists[k])
  point_order = args.tags #['ok', 'outOfFrame', 'synon', 'nonsynon']  # 'nonsense',
  ymin = sys.maxint
  ymax = -ymin
  for i, data in enumerate(point_order):
    ydata = [getattr(stat_dict[k], data) for k in order if k not in args.exclude]
    ymin = min(numpy.min(ydata), ymin)
    ymax = max(numpy.max(ydata), ymax)
    if args.distance:
      xdata = [dists[s] for s in order if s not in args.exclude]
      _range = numpy.max(xdata) - numpy.min(ydata)
      if args.jitter:
        xdata += numpy.random.uniform(low=0 - _range*0.01, high=_range*0.01,
                                      size=len(xdata))
    else:
      xdata = numpy.array(range(0, len(order))) + 0.05 * (i - 1.5)
    ax.add_line(
      lines.Line2D(xdata=xdata,
                   ydata=ydata,
                   color=ColorPicker(i, args),
                   marker='o',
                   markersize=args.markersize,
                   markerfacecolor=ColorPicker(i, args),
                   markeredgecolor='None',
                   alpha=args.alpha,
                   linewidth=0))
  if not args.distance:
    ax.xaxis.set_ticks(numpy.arange(0, len(order)))
    ax.xaxis.set_ticklabels(order, rotation=35,
                            horizontalalignment='right')
    ax.set_xlim([-1, len(order)])
  else:
    if args.is_log_x: ax.set_xscale('log')
    ax.set_xlabel('Phylogenetic distance from C57B6J')
  _range = ymax - ymin
  ax.set_ylim([ymin - 0.1 * _range, ymax + 0.1 * _range])
  _range = numpy.max(xdata) - numpy.min(xdata)
  ax.set_xlim([numpy.min(xdata) - 0.1 * _range,
               numpy.max(xdata) + 0.1 * _range])
  if args.perTranscript:
    ax.set_ylabel('Mutations per Transcript')
  else:
    ax.set_ylabel('Percent')
  ax.set_title(args.title)
  legend_labels = point_order
  proxy_plots = MakeProxyPlots(legend_labels, args)
  leg = plt.legend(proxy_plots, legend_labels, 'upper left', numpoints=1)
  leg._drawFrame = False


def main():
  parser = ArgumentParser()
  InitArguments(parser)
  args = parser.parse_args()
  CheckArguments(args, parser)
  fig, pdf = InitImage(args)
  ax = EstablishAxes(fig, args)
  stat_dict = ReadFiles(args)
  PlotData(stat_dict, ax, args)

  WriteImage(fig, pdf, args)

if __name__ == '__main__':
    main()
